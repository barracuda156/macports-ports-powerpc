From 202788721debabb9a7dfe6e8649a8a646309b328 Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <vital.had@gmail.com>
Date: Fri, 26 Jul 2024 16:22:14 +0800
Subject: [PATCH 3/3] Revert some breakages

Partly reverts https://github.com/wxWidgets/wxWidgets/commit/199a3f51ef2e6f4e99d0fdea410463ccda49fce2
---
 src/osx/cocoa/colour.mm     | 112 +++++++++++++++++++----
 src/osx/cocoa/dataview.mm   |  10 +-
 src/osx/cocoa/mediactrl.mm  |  34 ++++---
 src/osx/cocoa/notifmsg.mm   |  64 +++++++------
 src/osx/cocoa/power.mm      |  75 +++++++++++----
 src/osx/cocoa/utils.mm      |  57 +++++++-----
 src/osx/cocoa/utils_base.mm | 173 +++++++++++++++++++++++++----------
 src/osx/cocoa/window.mm     | 177 ++++++++++++++++++++----------------
 8 files changed, 478 insertions(+), 224 deletions(-)

diff --git src/osx/cocoa/colour.mm src/osx/cocoa/colour.mm
index 54707c36cb..36d7456ddb 100644
--- src/osx/cocoa/colour.mm
+++ src/osx/cocoa/colour.mm
@@ -18,28 +18,28 @@ class wxNSColorRefData : public wxColourRefData
 {
 public:
     wxNSColorRefData(WX_NSColor color);
-    
+
     wxNSColorRefData(const wxNSColorRefData& other);
 
     virtual ~wxNSColorRefData();
-    
+
     virtual CGFloat Red() const wxOVERRIDE;
     virtual CGFloat Green() const wxOVERRIDE;
     virtual CGFloat Blue() const wxOVERRIDE;
     virtual CGFloat Alpha() const wxOVERRIDE;
-    
+
     virtual bool IsSolid() const wxOVERRIDE;
 
     CGColorRef GetCGColor() const wxOVERRIDE;
-    
+
     virtual wxColourRefData* Clone() const wxOVERRIDE { return new wxNSColorRefData(*this); }
-    
+
     virtual WX_NSColor GetNSColor() const wxOVERRIDE;
     virtual WX_NSImage GetNSPatternImage() const wxOVERRIDE;
 private:
     static CGFloat GetCGColorComponent(CGColorRef col, int rgbaIndex);
     WX_NSColor m_nsColour;
-    
+
     wxDECLARE_NO_ASSIGN_CLASS(wxNSColorRefData);
 };
 
@@ -66,16 +66,16 @@ WX_NSColor wxNSColorRefData::GetNSColor() const
 CGFloat wxNSColorRefData::GetCGColorComponent(CGColorRef col, int rgbaIndex)
 {
     CGFloat value = 0.0;
-    
+
     if ( col )
     {
         wxCFRef<CGColorRef> rgbacol;
         CGColorSpaceModel model = CGColorSpaceGetModel(CGColorGetColorSpace(col));
         size_t noComp = CGColorGetNumberOfComponents(col);
         const CGFloat* components = CGColorGetComponents(col);
-        
+
         bool isRGB = true;
-        
+
         if (model == kCGColorSpaceModelMonochrome)
         {
             wxASSERT_MSG(1 <= noComp && noComp <= 2, "Monochrome Color unexpected components");
@@ -99,7 +99,7 @@ CGFloat wxNSColorRefData::GetCGColorComponent(CGColorRef col, int rgbaIndex)
                 isRGB = false;
             }
         }
-        
+
         if (isRGB)
         {
             wxASSERT_MSG(3 <= noComp && noComp <= 4, "RGB Color unexpected components");
@@ -110,7 +110,7 @@ CGFloat wxNSColorRefData::GetCGColorComponent(CGColorRef col, int rgbaIndex)
                 value = components[rgbaIndex];
         }
     }
-    
+
     return value;
 }
 
@@ -119,7 +119,7 @@ CGFloat wxNSColorRefData::Red() const
     wxOSXEffectiveAppearanceSetter helper;
     if ( NSColor* colRGBA = [m_nsColour colorUsingColorSpaceName:NSCalibratedRGBColorSpace] )
         return [colRGBA redComponent];
-    
+
     return GetCGColorComponent([m_nsColour CGColor], 0);
 }
 
@@ -128,7 +128,7 @@ CGFloat wxNSColorRefData::Green() const
     wxOSXEffectiveAppearanceSetter helper;
     if ( NSColor* colRGBA = [m_nsColour colorUsingColorSpaceName:NSCalibratedRGBColorSpace] )
         return [colRGBA greenComponent];
-    
+
     return GetCGColorComponent([m_nsColour CGColor], 1);
 }
 
@@ -137,7 +137,7 @@ CGFloat wxNSColorRefData::Blue() const
     wxOSXEffectiveAppearanceSetter helper;
     if ( NSColor* colRGBA = [m_nsColour colorUsingColorSpaceName:NSCalibratedRGBColorSpace] )
         return [colRGBA blueComponent];
-    
+
     return GetCGColorComponent([m_nsColour CGColor], 2);
 }
 
@@ -146,7 +146,7 @@ CGFloat wxNSColorRefData::Alpha() const
     wxOSXEffectiveAppearanceSetter helper;
     if ( NSColor* colRGBA = [m_nsColour colorUsingColorSpaceName:NSCalibratedRGBColorSpace] )
         return [colRGBA alphaComponent];
-    
+
     return GetCGColorComponent([m_nsColour CGColor], 3);
 }
 
@@ -178,8 +178,86 @@ WX_NSImage wxNSColorRefData::GetNSPatternImage() const
 
 WX_NSColor wxColourRefData::GetNSColor() const
 {
-    wxOSXEffectiveAppearanceSetter helper;
-    return [NSColor colorWithCalibratedRed:Red() green:Green() blue:Blue() alpha:Alpha() ];
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
+    if ( WX_IS_MACOS_AVAILABLE(10, 8) ) {
+        wxOSXEffectiveAppearanceSetter helper;
+        return [m_nsColour CGColor];
+    }
+#endif
+    CGColorRef cgcolor = NULL;
+
+    // Simplest case is when we can directly get the RGBA components:
+    if (NSColor* colRGBA = [m_nsColour colorUsingColorSpaceName:NSCalibratedRGBColorSpace])
+    {
+        CGFloat components[4];
+        [colRGBA getRed:&components[0] green:&components[1] blue:&components[2] alpha:&components[3]];
+
+        cgcolor = CGColorCreate(wxMacGetGenericRGBColorSpace(), components);
+    }
+    // Some colours use patterns, we can handle them with the help of CGColorRef
+    else if (NSColor* colPat = [m_nsColour colorUsingColorSpaceName:NSPatternColorSpace])
+    {
+        NSImage* const nsimage = [colPat patternImage];
+        if (nsimage)
+        {
+            NSSize size = [nsimage size];
+            NSRect r = NSMakeRect(0, 0, size.width, size.height);
+            CGImageRef cgimage = [nsimage CGImageForProposedRect:&r context:nil hints:nil];
+            if (cgimage)
+            {
+                // Callbacks for CGPatternCreate()
+                struct PatternCreateCallbacks
+                {
+                    static void Draw(void* info, CGContextRef ctx)
+                    {
+                        CGImageRef image = (CGImageRef)info;
+                        CGContextDrawImage(
+                            ctx,
+                            CGRectMake(0, 0, CGImageGetWidth(image), CGImageGetHeight(image)),
+                            image);
+                    }
+
+                    static void Release(void* WXUNUSED(info))
+                    {
+                        // Do not release the image here, we don't own it as it
+                        // comes from NSImage.
+                    }
+                };
+
+                const CGPatternCallbacks callbacks = {
+                    /* version: */ 0,
+                    &PatternCreateCallbacks::Draw,
+                    &PatternCreateCallbacks::Release
+                };
+
+                CGPatternRef pattern = CGPatternCreate(
+                                            cgimage,
+                                            CGRectMake(0, 0, size.width, size.height),
+                                            CGAffineTransformMake(1, 0, 0, 1, 0, 0),
+                                            size.width,
+                                            size.height,
+                                            kCGPatternTilingConstantSpacing,
+                                            /* isColored: */ true,
+                                            &callbacks
+                                       );
+                CGColorSpaceRef space = CGColorSpaceCreatePattern(NULL);
+                CGFloat components[1] = { 1.0 };
+                cgcolor = CGColorCreateWithPattern(space, pattern, components);
+                CGColorSpaceRelease(space);
+                CGPatternRelease(pattern);
+            }
+        }
+    }
+
+    if (cgcolor == NULL)
+    {
+        // Don't assert here, this will more likely than not result in a crash as
+        // colours are often created in drawing code which will be called again
+        // when the assert dialog is shown, resulting in a recursive assertion
+        // failure and, hence, a crash.
+        NSLog(@"Failed to convert NSColor \"%@\" to CGColorRef.", m_nsColour);
+    }
+    return cgcolor;
 }
 
 WX_NSImage wxColourRefData::GetNSPatternImage() const
diff --git src/osx/cocoa/dataview.mm src/osx/cocoa/dataview.mm
index 8e7fa9c0f4..00b18b9fd0 100644
--- src/osx/cocoa/dataview.mm
+++ src/osx/cocoa/dataview.mm
@@ -3005,11 +3005,19 @@ bool wxDataViewTextRenderer::MacRender()
             [par setLineBreakMode:[cell lineBreakMode]];
             // Tightening looks very ugly when combined with non-tightened rows,
             // so disabled it on OS X version where it's used:
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_11
             if ( WX_IS_MACOS_AVAILABLE(10, 11) )
+            {
                 [par setAllowsDefaultTighteningForTruncation:NO];
+            }
             else
+#endif
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
+            if ( WX_IS_MACOS_AVAILABLE(10, 10) )
+            {
                 [par setTighteningFactorForTruncation:0.0];
-
+            }
+#endif
             [str addAttribute:NSParagraphStyleAttributeName
                         value:par
                         range:NSMakeRange(0, [str length])];
diff --git src/osx/cocoa/mediactrl.mm src/osx/cocoa/mediactrl.mm
index 177dc3784b..a5f688b502 100644
--- src/osx/cocoa/mediactrl.mm
+++ src/osx/cocoa/mediactrl.mm
@@ -30,7 +30,7 @@
 #include "wx/osx/private.h"
 #include "wx/osx/private/available.h"
 
-#if wxOSX_USE_COCOA
+#if wxOSX_USE_COCOA && __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_9 && defined(__LP64__)
     #define wxOSX_USE_AVKIT 1
 #endif
 
@@ -273,6 +273,7 @@ private:
 
 #if wxOSX_USE_AVKIT
 
+WX_API_AVAILABLE_MACOS(10, 10)
 @interface wxAVPlayerView : AVPlayerView
 {
 }
@@ -392,12 +393,18 @@ bool wxAVMediaBackend::CreateControl(wxControl* inctrl, wxWindow* parent,
 
     WXWidget view = NULL;
 #if wxOSX_USE_AVKIT
-    view = [[wxAVPlayerView alloc] initWithFrame: r player:m_player];
-    [(wxAVPlayerView*) view setControlsStyle:AVPlayerViewControlsStyleNone];
-#else
-    view = [[wxAVView alloc] initWithFrame: r player:m_player];
+    if ( WX_IS_MACOS_AVAILABLE(10, 10) )
+    {
+        view = [[wxAVPlayerView alloc] initWithFrame: r player:m_player];
+        [(wxAVPlayerView*) view setControlsStyle:AVPlayerViewControlsStyleNone];
+    }
 #endif
 
+    if ( view == NULL )
+    {
+        view = [[wxAVView alloc] initWithFrame: r player:m_player];
+    }
+
 #if wxOSX_USE_IPHONE
     wxWidgetIPhoneImpl* impl = new wxWidgetIPhoneImpl(mediactrl,view);
 #else
@@ -554,14 +561,17 @@ bool wxAVMediaBackend::ShowPlayerControls(wxMediaCtrlPlayerControls flags)
 void wxAVMediaBackend::DoShowPlayerControls(wxMediaCtrlPlayerControls flags)
 {
 #if wxOSX_USE_AVKIT
-    NSView* view = m_ctrl->GetHandle();
-    if ( [view isKindOfClass:[wxAVPlayerView class]] )
+    if ( WX_IS_MACOS_AVAILABLE(10, 10) )
     {
-        wxAVPlayerView* playerView = (wxAVPlayerView*) view;
-        if (flags == wxMEDIACTRLPLAYERCONTROLS_NONE )
-            playerView.controlsStyle = AVPlayerViewControlsStyleNone;
-        else
-            playerView.controlsStyle = AVPlayerViewControlsStyleDefault;
+        NSView* view = m_ctrl->GetHandle();
+        if ( [view isKindOfClass:[wxAVPlayerView class]] )
+        {
+            wxAVPlayerView* playerView = (wxAVPlayerView*) view;
+            if (flags == wxMEDIACTRLPLAYERCONTROLS_NONE )
+                playerView.controlsStyle = AVPlayerViewControlsStyleNone;
+            else
+                playerView.controlsStyle = AVPlayerViewControlsStyleDefault;
+        }
     }
 #endif
 }
diff --git src/osx/cocoa/notifmsg.mm src/osx/cocoa/notifmsg.mm
index 3eb3459087..3f0dcc3631 100644
--- src/osx/cocoa/notifmsg.mm
+++ src/osx/cocoa/notifmsg.mm
@@ -29,7 +29,9 @@
 
 #include "wx/osx/private.h"
 #include "wx/osx/private/available.h"
+#include "wx/generic/notifmsg.h"
 #include "wx/private/notifmsg.h"
+#include "wx/generic/private/notifmsg.h"
 #include "wx/timer.h"
 #include "wx/platinfo.h"
 #include "wx/artprov.h"
@@ -39,6 +41,7 @@
 #include "wx/utils.h"
 #include <map>
 
+WX_API_AVAILABLE_MACOS(10, 8)
 @interface wxUserNotificationHandler : NSObject <NSUserNotificationCenterDelegate>
 
 @end
@@ -47,7 +50,7 @@
 // wxUserNotificationMsgImpl
 // ----------------------------------------------------------------------------
 
-class wxUserNotificationMsgImpl : public wxNotificationMessageImpl
+class WX_API_AVAILABLE_MACOS(10, 8) wxUserNotificationMsgImpl : public wxNotificationMessageImpl
 {
 public:
     wxUserNotificationMsgImpl(wxNotificationMessageBase* notification) :
@@ -55,13 +58,13 @@ public:
     {
         UseHandler();
         m_notif = [[NSUserNotification alloc] init];
-        
+
         // Build Id to unqiuely idendify this notification
         m_id = wxString::Format("%d_%d", (int)wxGetProcessId(), ms_notifIdBase++);
-        
+
         // Register the notification
         ms_activeNotifications[m_id] = this;
-        
+
         wxCFStringRef cfId(m_id);
         m_notif.userInfo = @{
                              @"wxId" : cfId.AsNSString()
@@ -79,63 +82,67 @@ public:
     {
         NSUserNotificationCenter* nc = [NSUserNotificationCenter defaultUserNotificationCenter];
         [nc deliverNotification:m_notif];
-        
+
         return true;
     }
-    
+
     virtual bool Close() wxOVERRIDE
     {
         NSUserNotificationCenter* nc = [NSUserNotificationCenter defaultUserNotificationCenter];
         [nc removeDeliveredNotification:m_notif];
-        
+
         return true;
     }
-    
+
     virtual void SetTitle(const wxString& title) wxOVERRIDE
     {
         wxCFStringRef cftitle(title);
         m_notif.title = cftitle.AsNSString();
     }
-    
+
     virtual void SetMessage(const wxString& message) wxOVERRIDE
     {
         wxCFStringRef cfmsg(message);
         m_notif.informativeText = cfmsg.AsNSString();
     }
-    
+
     virtual void SetParent(wxWindow *WXUNUSED(parent)) wxOVERRIDE
     {
     }
-    
+
     virtual void SetFlags(int WXUNUSED(flags)) wxOVERRIDE
     {
         // On OS X we do not add an icon based on the flags,
         // as this is primarily meant for custom icons
     }
-    
+
     virtual void SetIcon(const wxIcon& icon) wxOVERRIDE
     {
-        m_notif.contentImage = icon.GetNSImage();
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_9
+        // Additional icon in the notification is only supported on OS X 10.9+
+        if ( WX_IS_MACOS_AVAILABLE(10, 9) )
+            m_notif.contentImage = icon.GetNSImage();
+#endif
     }
-    
+
     virtual bool AddAction(wxWindowID actionid, const wxString &label) wxOVERRIDE
     {
         if (m_actions.size() >= 1) // Currently only 1 actions are supported
             return false;
-        
+
         wxString strLabel = label;
         if (strLabel.empty())
             strLabel = wxGetStockLabel(actionid, wxSTOCK_NOFLAGS);
         wxCFStringRef cflabel(strLabel);
-        
+
         m_actions.push_back(actionid);
-        
+
         if (m_actions.size() == 1)
             m_notif.actionButtonTitle = cflabel.AsNSString();
-        
+
         return true;
     }
-    
+
     void Activated(NSUserNotificationActivationType activationType)
     {
         switch (activationType)
@@ -170,19 +177,19 @@ public:
                 Close();
                 break;
             }
-                
+
             default:
                 break;
         };
     }
-    
+
     static void NotificationActivated(const wxString& notificationId, NSUserNotificationActivationType activationType)
     {
         wxUserNotificationMsgImpl* impl = ms_activeNotifications[notificationId];
         if (impl)
             impl->Activated(activationType);
     }
-    
+
     static void UseHandler()
     {
         if (!ms_handler)
@@ -191,17 +198,17 @@ public:
             [NSUserNotificationCenter defaultUserNotificationCenter].delegate = ms_handler;
         }
     }
-    
+
     static void ReleaseHandler()
     {
-        
+
     }
 
 private:
     NSUserNotification* m_notif;
     wxString m_id;
     wxVector<wxWindowID> m_actions;
-    
+
     static wxUserNotificationHandler* ms_handler;
     static std::map<wxString, wxUserNotificationMsgImpl*> ms_activeNotifications;
     static int ms_notifIdBase;
@@ -238,7 +245,12 @@ int wxUserNotificationMsgImpl::ms_notifIdBase = 1000;
 
 void wxNotificationMessage::Init()
 {
-    m_impl = new wxUserNotificationMsgImpl(this);
+    // Native notifications are not available prior to 10.8, fallback
+    // to generic ones on 10.7
+    if ( WX_IS_MACOS_AVAILABLE(10, 8) )
+        m_impl = new wxUserNotificationMsgImpl(this);
+    else
+        m_impl = new wxGenericNotificationMessageImpl(this);
 }
 
 #endif // wxUSE_NOTIFICATION_MESSAGE && defined(wxHAS_NATIVE_NOTIFICATION_MESSAGE)
diff --git src/osx/cocoa/power.mm src/osx/cocoa/power.mm
index f977a3f64a..502bcf7d98 100644
--- src/osx/cocoa/power.mm
+++ src/osx/cocoa/power.mm
@@ -37,31 +37,74 @@ bool UpdatePowerResourceUsage(wxPowerResourceKind kind, const wxString& reason)
         if( reason.IsEmpty())
             cfreason = wxString("User Activity");
 
-        if ( !g_processInfoActivity )
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_9
+        if ( WX_IS_MACOS_AVAILABLE(10, 9) )
         {
-            NSActivityOptions
-                options = NSActivityUserInitiated |
-                          NSActivityIdleSystemSleepDisabled;
+            // Use NSProcessInfo for 10.9 and newer
+            if ( !g_processInfoActivity )
+            {
+                NSActivityOptions
+                    options = NSActivityUserInitiated |
+                              NSActivityIdleSystemSleepDisabled;
+
+                if ( kind == wxPOWER_RESOURCE_SCREEN )
+                    options |= NSActivityIdleDisplaySleepDisabled;
+
+                g_processInfoActivity = [[NSProcessInfo processInfo]
+                                         beginActivityWithOptions:options
+                                         reason:cfreason.AsNSString()];
+                [g_processInfoActivity retain];
+                return true;
+            }
+        }
+        else
+#endif
+        if ( !g_pmAssertionID )
+        {
+            CFStringRef assertType;
 
             if ( kind == wxPOWER_RESOURCE_SCREEN )
-                options |= NSActivityIdleDisplaySleepDisabled;
-
-            g_processInfoActivity = [[NSProcessInfo processInfo]
-                                     beginActivityWithOptions:options
-                                     reason:cfreason.AsNSString()];
-            [g_processInfoActivity retain];
-            return true;
+                assertType = kIOPMAssertionTypeNoDisplaySleep;
+            else
+                assertType = kIOPMAssertionTypeNoIdleSleep;
+
+            // Use power manager API for < 10.9 systems
+            IOReturn success = IOPMAssertionCreateWithName
+                               (
+                                    assertType,
+                                    kIOPMAssertionLevelOn,
+                                    cfreason,
+                                    &g_pmAssertionID
+                               );
+            if ( success == kIOReturnSuccess )
+                return true;
         }
     }
     else if ( g_powerResourceSystemRefCount == 0 )
     {
-        if ( g_processInfoActivity )
+        // Release power assertion
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_9
+        if ( WX_IS_MACOS_AVAILABLE(10, 9) )
         {
-            [[NSProcessInfo processInfo]
-             endActivity:(id)g_processInfoActivity];
-            g_processInfoActivity = nil;
+            // Use NSProcessInfo for 10.9 and newer
+            if ( g_processInfoActivity )
+            {
+                [[NSProcessInfo processInfo]
+                 endActivity:(id)g_processInfoActivity];
+                g_processInfoActivity = nil;
 
-            return true;
+                return true;
+            }
+        }
+        else
+#endif
+        if ( g_pmAssertionID )
+        {
+            // Use power manager API for < 10.9 systems
+            IOReturn success = IOPMAssertionRelease(g_pmAssertionID);
+            g_pmAssertionID = 0;
+            if (success == kIOReturnSuccess)
+                return true;
         }
     }
 
diff --git src/osx/cocoa/utils.mm src/osx/cocoa/utils.mm
index 66d663325f..4a8845886c 100644
--- src/osx/cocoa/utils.mm
+++ src/osx/cocoa/utils.mm
@@ -49,15 +49,15 @@ void wxBell()
 - (void)applicationWillFinishLaunching:(NSNotification *)application
 {
     wxUnusedVar(application);
-    
+
     // we must install our handlers later than setting the app delegate, because otherwise our handlers
     // get overwritten in the meantime
 
     NSAppleEventManager *appleEventManager = [NSAppleEventManager sharedAppleEventManager];
-    
+
     [appleEventManager setEventHandler:self andSelector:@selector(handleGetURLEvent:withReplyEvent:)
                          forEventClass:kInternetEventClass andEventID:kAEGetURL];
-    
+
     [appleEventManager setEventHandler:self andSelector:@selector(handleOpenAppEvent:withReplyEvent:)
                          forEventClass:kCoreEventClass andEventID:kAEOpenApplication];
 
@@ -112,7 +112,14 @@ void wxBell()
 
         if ( activate ) {
             if ( [NSApp activationPolicy] == NSApplicationActivationPolicyAccessory ) {
-                [[NSRunningApplication currentApplication] activateWithOptions: NSApplicationActivateIgnoringOtherApps];
+                if ( WX_IS_MACOS_AVAILABLE(10, 9) ) {
+                    [[NSRunningApplication currentApplication] activateWithOptions:
+                    (NSApplicationActivateAllWindows | NSApplicationActivateIgnoringOtherApps)];
+                }
+                else {
+                    [self deactivate];
+                    [self activateIgnoringOtherApps:YES];
+                }
             }
             else {
                 [NSApp activateIgnoringOtherApps: YES];
@@ -151,12 +158,12 @@ void wxBell()
     {
         fileList.Add( wxCFStringRef::AsStringWithNormalizationFormC([fileNames objectAtIndex:i]) );
     }
-    
+
     if ( wxTheApp->OSXInitWasCalled() )
         wxTheApp->MacPrintFiles(fileList);
     else
         wxTheApp->OSXStorePrintFiles(fileList);
-    
+
     return NSPrintingSuccess;
 }
 
@@ -220,7 +227,7 @@ void wxBell()
     wxUnusedVar(sender);
     if ( !wxTheApp->OSXOnShouldTerminate() )
         return NSTerminateCancel;
-    
+
     return NSTerminateNow;
 }
 
@@ -248,7 +255,7 @@ void wxBell()
         wxTopLevelWindow * const win = static_cast<wxTopLevelWindow *>(*i);
         wxNonOwnedWindowImpl* winimpl = win ? win->GetNonOwnedPeer() : NULL;
         WXWindow nswindow = win ? win->GetWXWindow() : nil;
-        
+
         if ( nswindow && [nswindow hidesOnDeactivate] == NO && winimpl)
             winimpl->RestoreWindowLevel();
     }
@@ -266,7 +273,7 @@ void wxBell()
     {
         wxTopLevelWindow * const win = static_cast<wxTopLevelWindow *>(*i);
         WXWindow nswindow = win ? win->GetWXWindow() : nil;
-        
+
         if ( nswindow && [nswindow level] == kCGFloatingWindowLevel && [nswindow hidesOnDeactivate] == NO )
             [nswindow setLevel:kCGNormalWindowLevel];
     }
@@ -335,7 +342,7 @@ void wxBell()
     // NSAlerts don't need nor respond to orderOut
     if ([sheet respondsToSelector:@selector(orderOut:)])
         [sheet orderOut: self];
-        
+
     if (impl)
         impl->ModalFinishedCallback(sheet, returnCode);
 }
@@ -370,7 +377,7 @@ void wxBell()
     if ([anEvent type] == NSKeyUp && ([anEvent modifierFlags] & NSCommandKeyMask))
         [[self keyWindow] sendEvent:anEvent];
     else
-        [super sendEvent:anEvent];    
+        [super sendEvent:anEvent];
 }
 
 @end
@@ -397,7 +404,7 @@ bool wxApp::DoInitGui()
         [NSColor setIgnoresAlpha:NO];
     }
     gNSLayoutManager = [[NSLayoutManager alloc] init];
-    
+
     // This call makes it so that appplication:openFile: doesn't get bogus calls
     // from Cocoa doing its own parsing of the argument string. And yes, we need
     // to use a string with a boolean value in it. That's just how it works.
@@ -508,23 +515,23 @@ void wxGetMousePosition( int* x, int* y )
 wxMouseState wxGetMouseState()
 {
     wxMouseState ms;
-    
+
     wxPoint pt = wxGetMousePosition();
     ms.SetX(pt.x);
     ms.SetY(pt.y);
-    
+
     NSUInteger modifiers = [NSEvent modifierFlags];
     NSUInteger buttons = [NSEvent pressedMouseButtons];
-    
+
     ms.SetLeftDown( (buttons & 0x01) != 0 );
     ms.SetMiddleDown( (buttons & 0x04) != 0 );
     ms.SetRightDown( (buttons & 0x02) != 0 );
-    
+
     ms.SetRawControlDown(modifiers & NSControlKeyMask);
     ms.SetShiftDown(modifiers & NSShiftKeyMask);
     ms.SetAltDown(modifiers & NSAlternateKeyMask);
     ms.SetControlDown(modifiers & NSCommandKeyMask);
-    
+
     return ms;
 }
 
@@ -544,10 +551,10 @@ void wxBeginBusyCursor(const wxCursor *cursor)
     {
         NSEnumerator *enumerator = [[[NSApplication sharedApplication] windows] objectEnumerator];
         id object;
-        
+
         while ((object = [enumerator nextObject])) {
             [(NSWindow*) object disableCursorRects];
-        }        
+        }
 
         gMacStoredActiveCursor = gMacCurrentCursor;
         cursor->MacInstall();
@@ -567,10 +574,10 @@ void wxEndBusyCursor()
     {
         NSEnumerator *enumerator = [[[NSApplication sharedApplication] windows] objectEnumerator];
         id object;
-        
+
         while ((object = [enumerator nextObject])) {
             [(NSWindow*) object enableCursorRects];
-        }        
+        }
 
         wxSetCursor(wxNullCursor);
 
@@ -603,10 +610,10 @@ wxBitmap wxWindowDCImpl::DoGetAsBitmap(const wxRect *subrect) const
         // however the new implementation does not take into account the backgroundViews, and I'm not sure about
         // until we're
         // sure the replacement is always better
-         
+
         bool useOldImplementation = false;
         NSBitmapImageRep *rep = nil;
-        
+
         if ( useOldImplementation )
         {
             [view lockFocus];
@@ -621,7 +628,7 @@ wxBitmap wxWindowDCImpl::DoGetAsBitmap(const wxRect *subrect) const
             rep = [view bitmapImageRepForCachingDisplayInRect:[view bounds]];
             [view cacheDisplayInRect:[view bounds] toBitmapImageRep:rep];
         }
-        
+
         CGImageRef cgImageRef = (CGImageRef)[rep CGImage];
 
         CGRect r = CGRectMake( 0 , 0 , CGImageGetWidth(cgImageRef)  , CGImageGetHeight(cgImageRef) );
@@ -633,7 +640,7 @@ wxBitmap wxWindowDCImpl::DoGetAsBitmap(const wxRect *subrect) const
 
         // since our context is upside down we dont use CGContextDrawImage
         wxMacDrawCGImage( (CGContextRef) bitmap.GetHBITMAP() , &r, cgImageRef ) ;
-        
+
         if ( useOldImplementation )
             [rep release];
     }
diff --git src/osx/cocoa/utils_base.mm src/osx/cocoa/utils_base.mm
index 337d64e5f0..f134cc83e7 100644
--- src/osx/cocoa/utils_base.mm
+++ src/osx/cocoa/utils_base.mm
@@ -24,6 +24,11 @@
 #include "wx/osx/private.h"
 #include "wx/osx/private/available.h"
 
+#if (defined(__WXOSX_COCOA__) && __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10) \
+    || (defined(__WXOSX_IPHONE__) && defined(__IPHONE_8_0))
+    #define wxHAS_NSPROCESSINFO 1
+#endif
+
 #include <AppKit/AppKit.h>
 
 #if wxUSE_SOCKETS
@@ -38,28 +43,90 @@ wxSocketManager *wxOSXSocketManagerCF = NULL;
 // our OS version is the same in non GUI and GUI cases
 wxOperatingSystemId wxGetOsVersion(int *verMaj, int *verMin, int *verMicro)
 {
-    NSOperatingSystemVersion osVer = [NSProcessInfo processInfo].operatingSystemVersion;
+#ifdef wxHAS_NSPROCESSINFO
+    // Note: we don't use WX_IS_MACOS_AVAILABLE() here because these properties
+    // are only officially supported since 10.10, but are actually available
+    // under 10.9 too, so we prefer to check for them explicitly and suppress
+    // the warnings that using without a __builtin_available() check around
+    // them generates.
+    wxCLANG_WARNING_SUPPRESS(unguarded-availability)
+
+    if ([NSProcessInfo instancesRespondToSelector:@selector(operatingSystemVersion)])
+    {
+        NSOperatingSystemVersion osVer = [NSProcessInfo processInfo].operatingSystemVersion;
+
+        if ( verMaj != NULL )
+            *verMaj = osVer.majorVersion;
+
+        if ( verMin != NULL )
+            *verMin = osVer.minorVersion;
+
+        if ( verMicro != NULL )
+            *verMicro = osVer.patchVersion;
+    }
+
+    wxCLANG_WARNING_RESTORE(unguarded-availability)
+
+    else
+#endif
+    {
+        // On OS X versions prior to 10.10 NSProcessInfo does not provide the OS version
+        // Deprecated Gestalt calls are required instead
+wxGCC_WARNING_SUPPRESS(deprecated-declarations)
+        SInt32 maj, min, micro;
+#ifdef __WXOSX_IPHONE__
+        maj = 7;
+        min = 0;
+        micro = 0;
+#else
+        Gestalt(gestaltSystemVersionMajor, &maj);
+        Gestalt(gestaltSystemVersionMinor, &min);
+        Gestalt(gestaltSystemVersionBugFix, &micro);
+#endif
+wxGCC_WARNING_RESTORE()
 
     if ( verMaj != NULL )
-        *verMaj = osVer.majorVersion;
+        *verMaj = maj;
 
     if ( verMin != NULL )
-        *verMin = osVer.minorVersion;
+        *verMin = min;
 
     if ( verMicro != NULL )
-        *verMicro = osVer.patchVersion;
+        *verMicro = micro;
+    }
 
     return wxOS_MAC_OSX_DARWIN;
 }
 
 bool wxCheckOsVersion(int majorVsn, int minorVsn, int microVsn)
 {
-    NSOperatingSystemVersion osVer;
-    osVer.majorVersion = majorVsn;
-    osVer.minorVersion = minorVsn;
-    osVer.patchVersion = microVsn;
+#ifdef wxHAS_NSPROCESSINFO
+    // As above, this API is effectively available earlier than its
+    // availability attribute indicates, so check for it manually.
+    wxCLANG_WARNING_SUPPRESS(unguarded-availability)
+
+    if ([NSProcessInfo instancesRespondToSelector:@selector(isOperatingSystemAtLeastVersion:)])
+    {
+        NSOperatingSystemVersion osVer;
+        osVer.majorVersion = majorVsn;
+        osVer.minorVersion = minorVsn;
+        osVer.patchVersion = microVsn;
+
+        return [[NSProcessInfo processInfo] isOperatingSystemAtLeastVersion:osVer] != NO;
+    }
+
+    wxCLANG_WARNING_RESTORE(unguarded-availability)
+
+    else
+#endif
+    {
+        int majorCur, minorCur, microCur;
+        wxGetOsVersion(&majorCur, &minorCur, &microCur);
 
-    return [[NSProcessInfo processInfo] isOperatingSystemAtLeastVersion:osVer] != NO;
+        return majorCur > majorVsn
+            || (majorCur == majorVsn && minorCur >= minorVsn)
+            || (majorCur == majorVsn && minorCur == minorVsn && microCur >= microVsn);
+    }
 }
 
 wxString wxGetOsDescription()
@@ -181,58 +248,68 @@ bool wxCocoaLaunch(const char* const* argv, pid_t &pid)
 
     NSMutableArray *params = [[NSMutableArray alloc] init];
 
-    // Loop through command line arguments to the bundle,
-    // turn them into CFURLs and then put them in cfaFiles
-    // For use to launch services call
-    for( ; *argv != NULL; ++argv )
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
+    if (  WX_IS_MACOS_AVAILABLE(10, 10) )
     {
-        NSURL *cfurlCurrentFile;
-        wxString dir( *argv );
-        if( wxFileName::DirExists(dir) )
-        {
-            // First, try creating as a directory
-            cfurlCurrentFile = [NSURL fileURLWithPath:wxCFStringRef(dir).AsNSString() isDirectory:YES];
-        }
-        else if( wxFileName::FileExists(dir) )
-        {
-            // And if it isn't a directory try creating it
-            // as a regular file
-            cfurlCurrentFile = [NSURL fileURLWithPath:wxCFStringRef(dir).AsNSString() isDirectory:NO];
-        }
-        else
+        // Loop through command line arguments to the bundle,
+        // turn them into CFURLs and then put them in cfaFiles
+        // For use to launch services call
+        for( ; *argv != NULL; ++argv )
         {
-            // Argument did not refer to
-            // an entry in the local filesystem,
-            // so try creating it through CFURLCreateWithString
-            cfurlCurrentFile = [NSURL URLWithString:wxCFStringRef(dir).AsNSString()];
-        }
+            NSURL *cfurlCurrentFile;
+            wxString dir( *argv );
+            if( wxFileName::DirExists(dir) )
+            {
+                // First, try creating as a directory
+                cfurlCurrentFile = [NSURL fileURLWithPath:wxCFStringRef(dir).AsNSString() isDirectory:YES];
+            }
+            else if( wxFileName::FileExists(dir) )
+            {
+                // And if it isn't a directory try creating it
+                // as a regular file
+                cfurlCurrentFile = [NSURL fileURLWithPath:wxCFStringRef(dir).AsNSString() isDirectory:NO];
+            }
+            else
+            {
+                // Argument did not refer to
+                // an entry in the local filesystem,
+                // so try creating it through CFURLCreateWithString
+                cfurlCurrentFile = [NSURL URLWithString:wxCFStringRef(dir).AsNSString()];
+            }
 
-        // Continue in the loop if the CFURL could not be created
-        if(cfurlCurrentFile == nil)
-        {
-            wxLogDebug(
-                       wxT("wxCocoaLaunch Could not create NSURL for argument:%s"),
-                       *argv);
-            continue;
-        }
+            // Continue in the loop if the CFURL could not be created
+            if(cfurlCurrentFile == nil)
+            {
+                wxLogDebug(
+                           wxT("wxCocoaLaunch Could not create NSURL for argument:%s"),
+                           *argv);
+                continue;
+            }
 
-        // Add the valid CFURL to the argument array and then
-        // release it as the CFArray adds a ref count to it
-        [params addObject:cfurlCurrentFile];
+            // Add the valid CFURL to the argument array and then
+            // release it as the CFArray adds a ref count to it
+            [params addObject:cfurlCurrentFile];
+        }
     }
+#endif
 
     NSWorkspace *ws = [NSWorkspace sharedWorkspace];
 
 
     NSRunningApplication *app = nil;
 
-    if ( [params count] > 0 )
-        app = [ws openURLs:params withApplicationAtURL:url
-                   options:NSWorkspaceLaunchAsync
-             configuration:[NSDictionary dictionary]
-                     error:&error];
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
+    if ( WX_IS_MACOS_AVAILABLE(10, 10) )
+    {
+        if ( [params count] > 0 )
+            app = [ws openURLs:params withApplicationAtURL:url
+                       options:NSWorkspaceLaunchAsync
+                 configuration:[NSDictionary dictionary]
+                         error:&error];
+    }
 
     if ( app == nil )
+#endif
     {
         app = [ws launchApplicationAtURL:url
                                  options:NSWorkspaceLaunchAsync
diff --git src/osx/cocoa/window.mm src/osx/cocoa/window.mm
index 6e5256f357..f1a2c6e602 100644
--- src/osx/cocoa/window.mm
+++ src/osx/cocoa/window.mm
@@ -130,12 +130,12 @@ WXWidget wxWidgetImpl::FindFocus()
 wxWidgetImpl* wxWidgetImpl::FindBestFromWXWidget(WXWidget control)
 {
     wxWidgetImpl* impl = FindFromWXWidget(control);
-    
+
     // NSScrollViews can have their subviews like NSClipView
     // therefore check and use the NSScrollView peer in that case
     if ( impl == NULL && [[control superview] isKindOfClass:[NSScrollView class]])
         impl = FindFromWXWidget([control superview]);
-    
+
     return impl;
 }
 
@@ -248,7 +248,7 @@ NSRect wxOSXGetFrameForControl( wxWindowMac* window , const wxPoint& pos , const
         const UniCharCount maxStringLength = 255;
         UniCharCount actualStringLength = 0;
         UniChar unicodeString[maxStringLength];
-        
+
         OSStatus status = UCKeyTranslate(keyboardLayout,
                                          [self keyCode],
                                          kUCKeyActionDown,
@@ -259,7 +259,7 @@ NSRect wxOSXGetFrameForControl( wxWindowMac* window , const wxPoint& pos , const
                                          maxStringLength,
                                          &actualStringLength,
                                          unicodeString);
-        
+
         if(status == noErr)
             result = [NSString stringWithCharacters:unicodeString length:(NSInteger)actualStringLength];
     }
@@ -382,7 +382,7 @@ long wxOSXTranslateCocoaKey( NSEvent* event, int eventType )
         default:
             break;
     }
-    
+
     // Check for NUMPAD keys.  For KEY_UP/DOWN events we need to use the
     // WXK_NUMPAD constants, but for the CHAR event we want to use the
     // standard ascii values
@@ -552,7 +552,7 @@ void wxWidgetCocoaImpl::SetupKeyEvent(wxKeyEvent &wxevent , NSEvent * nsEvent, N
 UInt32 g_lastButton = 0 ;
 bool g_lastButtonWasFakeRight = false ;
 
-// better scroll wheel support 
+// better scroll wheel support
 // see http://lists.apple.com/archives/cocoa-dev/2007/Feb/msg00050.html
 
 @interface NSEvent (DeviceDelta)
@@ -570,20 +570,20 @@ wxSetupCoordinates(NSView* view, wxCoord &x, wxCoord &y, NSEvent* nsEvent)
 {
     NSRect locationInWindow = NSZeroRect;
     locationInWindow.origin = [nsEvent locationInWindow];
-    
+
     // adjust coordinates for the window of the target view
     if ( [nsEvent window] != [view window] )
     {
         if ( [nsEvent window] != nil )
             locationInWindow = [[nsEvent window] convertRectToScreen:locationInWindow];
-        
+
         if ( [view window] != nil )
             locationInWindow = [[view window] convertRectFromScreen:locationInWindow];
     }
-    
+
     NSPoint locationInView = [view convertPoint:locationInWindow.origin fromView:nil];
     wxPoint locationInViewWX = wxFromNSPoint( view, locationInView );
-        
+
     x = locationInViewWX.x;
     y = locationInViewWX.y;
 
@@ -598,7 +598,7 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
 {
     int eventType = [nsEvent type];
     UInt32 modifiers = [nsEvent modifierFlags] ;
-    
+
     SetupCoordinates(wxevent.m_x, wxevent.m_y, nsEvent);
 
     // these parameters are not given for all events
@@ -783,7 +783,7 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
                 deltaX = [nsEvent scrollingDeltaX] * 10;
                 deltaY = [nsEvent scrollingDeltaY] * 10;
             }
-            
+
             wxevent.m_wheelDelta = 10;
             wxevent.m_wheelInverted = [nsEvent isDirectionInvertedFromDevice];
             wxevent.m_linesPerAction = 1;
@@ -817,12 +817,12 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
         case NSMouseMoved :
             wxevent.SetEventType( wxEVT_MOTION ) ;
             break;
-        
+
         case NSEventTypeMagnify:
             wxevent.SetEventType( wxEVT_MAGNIFY );
             wxevent.m_magnification = [nsEvent magnification];
             break;
-            
+
         default :
             break ;
     }
@@ -872,7 +872,7 @@ static void SetDrawingEnabledIfFrozenRecursive(wxWidgetCocoaImpl *impl, bool ena
     }
 }
 
-/* idea taken from webkit sources: overwrite the methods that (private) NSToolTipManager will use to attach its tracking rectangle 
+/* idea taken from webkit sources: overwrite the methods that (private) NSToolTipManager will use to attach its tracking rectangle
  * then when changing the tooltip send fake view-exit and view-enter methods which will lead to a tooltip refresh
  */
 
@@ -927,7 +927,7 @@ static void SetDrawingEnabledIfFrozenRecursive(wxWidgetCocoaImpl *impl, bool ena
         CALayer* layer = self.layer;
         layer.contentsFormat = kCAContentsFormatRGBA8Uint;
     }
-    
+
     [super viewWillDraw];
 }
 #endif
@@ -969,7 +969,7 @@ void wxOSX_insertText(NSView* self, SEL _cmd, NSString* text);
 }
 
 - (NSRange)selectedRange
-{    
+{
     return NSMakeRange(NSNotFound, 0);
 }
 
@@ -1070,7 +1070,7 @@ void wxOSX_cursorUpdate(NSView* self, SEL _cmd, NSEvent *event)
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
     if (impl == NULL)
         return;
-    
+
     impl->cursorUpdate(event, self, _cmd);
 }
 
@@ -1103,6 +1103,8 @@ void wxOSX_insertText(NSView* self, SEL _cmd, NSString* text)
     impl->insertText(text, self, _cmd);
 }
 
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
+WX_API_AVAILABLE_MACOS(10, 10)
 void wxOSX_panGestureEvent(NSView* self, SEL WXUNUSED(_cmd), NSPanGestureRecognizer* panGestureRecognizer)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1112,6 +1114,7 @@ void wxOSX_panGestureEvent(NSView* self, SEL WXUNUSED(_cmd), NSPanGestureRecogni
     impl->PanGestureEvent(panGestureRecognizer);
 }
 
+WX_API_AVAILABLE_MACOS(10, 10)
 void wxOSX_zoomGestureEvent(NSView* self, SEL WXUNUSED(_cmd), NSMagnificationGestureRecognizer* magnificationGestureRecognizer)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1121,6 +1124,7 @@ void wxOSX_zoomGestureEvent(NSView* self, SEL WXUNUSED(_cmd), NSMagnificationGes
     impl->ZoomGestureEvent(magnificationGestureRecognizer);
 }
 
+WX_API_AVAILABLE_MACOS(10, 10)
 void wxOSX_rotateGestureEvent(NSView* self, SEL WXUNUSED(_cmd), NSRotationGestureRecognizer* rotationGestureRecognizer)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1130,6 +1134,7 @@ void wxOSX_rotateGestureEvent(NSView* self, SEL WXUNUSED(_cmd), NSRotationGestur
     impl->RotateGestureEvent(rotationGestureRecognizer);
 }
 
+WX_API_AVAILABLE_MACOS(10, 10)
 void wxOSX_longPressEvent(NSView* self, SEL WXUNUSED(_cmd), NSPressGestureRecognizer* pressGestureRecognizer)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1139,6 +1144,7 @@ void wxOSX_longPressEvent(NSView* self, SEL WXUNUSED(_cmd), NSPressGestureRecogn
     impl->LongPressEvent(pressGestureRecognizer);
 }
 
+WX_API_AVAILABLE_MACOS(10, 10)
 void wxOSX_touchesBegan(NSView* self, SEL WXUNUSED(_cmd), NSEvent *event)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1148,6 +1154,7 @@ void wxOSX_touchesBegan(NSView* self, SEL WXUNUSED(_cmd), NSEvent *event)
     impl->TouchesBegan(event);
 }
 
+WX_API_AVAILABLE_MACOS(10, 10)
 void wxOSX_touchesMoved(NSView* self, SEL WXUNUSED(_cmd), NSEvent *event)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1157,6 +1164,7 @@ void wxOSX_touchesMoved(NSView* self, SEL WXUNUSED(_cmd), NSEvent *event)
     impl->TouchesMoved(event);
 }
 
+WX_API_AVAILABLE_MACOS(10, 10)
 void wxOSX_touchesEnded(NSView* self, SEL WXUNUSED(_cmd), NSEvent *event)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1165,6 +1173,7 @@ void wxOSX_touchesEnded(NSView* self, SEL WXUNUSED(_cmd), NSEvent *event)
 
     impl->TouchesEnded(event);
 }
+#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
 
 BOOL wxOSX_acceptsFirstResponder(NSView* self, SEL _cmd)
 {
@@ -1229,7 +1238,7 @@ void wxOSX_drawRect(NSView* self, SEL _cmd, NSRect rect)
             wxWindow* win = impl->GetWXPeer();
             if ( win->UseBgCol() )
             {
-                
+
                 CGContextRef context = [[NSGraphicsContext currentContext] CGContext];
                 CGContextSaveGState( context );
 
@@ -1240,7 +1249,7 @@ void wxOSX_drawRect(NSView* self, SEL _cmd, NSRect rect)
                 CGContextRestoreGState( context );
             }
         }
-        else 
+        else
         {
             // just call the superclass handler, we don't need any custom wx drawing
             // here and it seems to work fine:
@@ -1520,7 +1529,7 @@ void wxWidgetCocoaImpl::cursorUpdate(WX_NSEvent event, WXWidget slf, void *_cmd)
 bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
 {
     extern wxCursor gGlobalCursor;
-    
+
     if ( gGlobalCursor.IsOk() )
     {
         gGlobalCursor.MacInstall();
@@ -1532,7 +1541,7 @@ bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
         wxCoord x,y;
         SetupCoordinates(x, y, event);
         wxPoint cursorPoint( x , y ) ;
-        
+
         while ( cursorTarget && !cursorTarget->MacSetupCursor( cursorPoint ) )
         {
             // at least in GTK cursor events are not propagated either ...
@@ -1544,7 +1553,7 @@ bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
                 cursorPoint += cursorTarget->GetPosition();
 #endif
         }
-        
+
         return cursorTarget != NULL;
     }
 }
@@ -1559,7 +1568,7 @@ void wxWidgetCocoaImpl::keyEvent(WX_NSEvent event, WXWidget slf, void *_cmd)
 
     if ( [event type] == NSKeyDown )
     {
-        // there are key equivalents that are not command-combos and therefore not handled by cocoa automatically, 
+        // there are key equivalents that are not command-combos and therefore not handled by cocoa automatically,
         // therefore we call the menubar directly here, exit if the menu is handling the shortcut
         if ( [[[NSApplication sharedApplication] mainMenu] performKeyEquivalent:event] )
         {
@@ -1570,21 +1579,23 @@ void wxWidgetCocoaImpl::keyEvent(WX_NSEvent event, WXWidget slf, void *_cmd)
 
         BeginNativeKeyDownEvent(event);
     }
-    
+
     if ( GetFocusedViewInWindow([slf window]) != slf || m_hasEditor || !DoHandleKeyEvent(event) )
     {
         wxOSX_EventHandlerPtr superimpl = (wxOSX_EventHandlerPtr) [[slf superclass] instanceMethodForSelector:(SEL)_cmd];
         superimpl(slf, (SEL)_cmd, event);
     }
-    
+
     if ( [event type] == NSKeyDown )
     {
         EndNativeKeyDownEvent();
     }
 }
 
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
+
 // Class containing data used for gestures support.
-class wxCocoaGesturesImpl
+class WX_API_AVAILABLE_MACOS(10, 10) wxCocoaGesturesImpl
 {
 public:
     wxCocoaGesturesImpl(wxWidgetCocoaImpl* impl, NSView* view, int eventsMask)
@@ -2156,6 +2167,7 @@ void wxCocoaGesturesImpl::TouchesEnded(NSEvent* event)
         m_activeGestures &= ~press_and_tap;
     }
 }
+#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
 
 void wxWidgetCocoaImpl::insertText(NSString* text, WXWidget slf, void *_cmd)
 {
@@ -2258,7 +2270,7 @@ bool wxWidgetCocoaImpl::resignFirstResponder(WXWidget slf, void *_cmd)
 {
     wxOSX_FocusHandlerPtr superimpl = (wxOSX_FocusHandlerPtr) [[slf superclass] instanceMethodForSelector:(SEL)_cmd];
     BOOL r = superimpl(slf, (SEL)_cmd);
-    
+
     // wxNSTextFields and wxNSComboBoxes have an editor as real responder, therefore they get
     // a resign notification when their editor takes over, don't trigger  event here, the control
     // gets a controlTextDidEndEditing notification which will send a focus kill.
@@ -2282,7 +2294,7 @@ bool wxWidgetCocoaImpl::isFlipped(WXWidget slf, void *WXUNUSED(_cmd))
 void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
 {
     // preparing the update region
-    
+
     wxRegion updateRgn;
 
     // since adding many rects to a region is a costly process, by default use the bounding rect
@@ -2297,7 +2309,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
 #else
     updateRgn.Union(wxFromNSRect(slf,*(NSRect*)rect));
 #endif
-    
+
     wxWindow* wxpeer = GetWXPeer();
 
     if ( wxpeer->MacGetLeftBorderSize() != 0 || wxpeer->MacGetTopBorderSize() != 0 )
@@ -2305,13 +2317,13 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         // as this update region is in native window locals we must adapt it to wx window local
         updateRgn.Offset( wxpeer->MacGetLeftBorderSize() , wxpeer->MacGetTopBorderSize() );
     }
-    
+
     // Restrict the update region to the shape of the window, if any, and also
     // remember the region that we need to clear later.
     wxNonOwnedWindow* const tlwParent = wxpeer->MacGetTopLevelWindow();
     if ( tlwParent == NULL )
         return;
-    
+
     const bool isTopLevel = tlwParent == wxpeer;
     wxRegion clearRgn;
     if ( tlwParent->GetWindowStyle() & wxFRAME_SHAPED )
@@ -2335,7 +2347,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             }
         }
     }
-    
+
     wxpeer->GetUpdateRegion() = updateRgn;
 
     // setting up the drawing context
@@ -2345,7 +2357,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
     if ( context != NULL )
     {
         CGContextSaveGState( context );
-        
+
 #if OSX_DEBUG_DRAWING
         CGContextBeginPath( context );
         CGContextMoveToPoint(context, 0, 0);
@@ -2360,7 +2372,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         CGContextClosePath( context );
         CGContextStrokePath(context);
 #endif
-        
+
         if ( ![slf isFlipped] )
         {
             CGContextTranslateCTM( context, 0,  [m_osxView bounds].size.height );
@@ -2374,7 +2386,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         CGContextRestoreGState( context );
         CGContextSaveGState( context );
     }
-    
+
     if ( !handled )
     {
         // call super
@@ -2387,7 +2399,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             CGContextSaveGState( context );
         }
     }
-    
+
     if ( context != NULL )
     {
         // as we called restore above, we have to flip again if necessary
@@ -2396,7 +2408,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             CGContextTranslateCTM( context, 0,  [m_osxView bounds].size.height );
             CGContextScaleCTM( context, 1, -1 );
         }
-        
+
         if ( isTopLevel )
         {
             // We also need to explicitly draw the part of the top level window
@@ -2410,7 +2422,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
                 dc.SetDeviceClippingRegion(clearRgn);
                 dc.Clear();
             }
-            
+
 #if wxUSE_GRAPHICS_CONTEXT
             // If the window shape is defined by a path, stroke the path to show
             // the window border.
@@ -2424,7 +2436,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             }
 #endif // wxUSE_GRAPHICS_CONTEXT
         }
-        
+
         wxpeer->MacPaintChildrenBorders();
         CGContextRestoreGState( context );
     }
@@ -2448,7 +2460,7 @@ void wxWidgetCocoaImpl::controlDoubleAction( WXWidget WXUNUSED(slf), void *WXUNU
 void wxWidgetCocoaImpl::controlTextDidChange()
 {
     wxWindow* wxpeer = (wxWindow*)GetWXPeer();
-    if ( wxpeer ) 
+    if ( wxpeer )
     {
         // since native rtti doesn't have to be enabled and wx' rtti is not aware of the mixin wxTextEntry, workaround is needed
         if ( wxTextCtrl *tc = wxDynamicCast( wxpeer , wxTextCtrl ) )
@@ -2458,7 +2470,7 @@ void wxWidgetCocoaImpl::controlTextDidChange()
         }
         else if ( wxComboBox *cb = wxDynamicCast( wxpeer , wxComboBox ) )
             cb->SendTextUpdatedEventIfAllowed();
-        else 
+        else
         {
             wxFAIL_MSG("Unexpected class for controlTextDidChange event");
         }
@@ -2500,7 +2512,7 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
     wxOSX_CLASS_ADD_METHOD(c, @selector(mouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(rightMouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(otherMouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
-    
+
     wxOSX_CLASS_ADD_METHOD(c, @selector(acceptsFirstMouse:), (IMP) wxOSX_acceptsFirstMouse, "v@:@" )
 
     wxOSX_CLASS_ADD_METHOD(c, @selector(scrollWheel:), (IMP) wxOSX_mouseEvent, "v@:@" )
@@ -2524,7 +2536,7 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
 #if !wxOSX_USE_NATIVE_FLIPPED
     wxOSX_CLASS_ADD_METHOD(c, @selector(isFlipped), (IMP) wxOSX_isFlipped, "c@:" )
 #endif
-        
+
     if ( !(skipFlags & wxOSXSKIP_DRAW) )
         wxOSX_CLASS_ADD_METHOD(c, @selector(drawRect:), (IMP) wxOSX_drawRect, "v@:{_NSRect={_NSPoint=ff}{_NSSize=ff}}" )
 
@@ -2572,7 +2584,7 @@ wxWidgetImpl( peer, flags )
     // check if the user wants to create the control initially hidden
     if ( !peer->IsShown() )
         SetVisibility(false);
-    
+
     // gc aware handling
     if ( m_osxView )
         CFRetain(m_osxView);
@@ -2601,7 +2613,7 @@ wxWidgetCocoaImpl::~wxWidgetCocoaImpl()
 {
     if ( GetWXPeer() && GetWXPeer()->IsFrozen() )
         SetDrawingEnabled(true);
-    
+
     RemoveAssociations( this );
 
     if ( !IsRootControl() )
@@ -2614,7 +2626,9 @@ wxWidgetCocoaImpl::~wxWidgetCocoaImpl()
     if ( m_osxView )
         CFRelease(m_osxView);
 
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
     wxCocoaGestures::EraseForObject(this);
+#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
 }
 
 void wxWidgetCocoaImpl::BeginNativeKeyDownEvent( NSEvent* event )
@@ -2655,7 +2669,7 @@ wxWidgetCocoaNativeKeyDownSuspender::wxWidgetCocoaNativeKeyDownSuspender( wxWidg
 {
     m_nsevent = m_target->m_lastKeyDownEvent;
     m_wxsent = m_target->m_lastKeyDownWXSent;
-    
+
     m_target->m_lastKeyDownEvent = nil;
 }
 
@@ -2673,7 +2687,7 @@ bool wxWidgetCocoaImpl::IsVisible() const
 void wxWidgetCocoaImpl::SetVisibility( bool visible )
 {
     [m_osxView setHidden:(visible ? NO:YES)];
-    
+
     // trigger redraw upon shown for layer-backed views
     if ( WX_IS_MACOS_AVAILABLE(10, 14 ) )
         if( !m_osxView.isHiddenOrHasHiddenAncestor )
@@ -3076,7 +3090,7 @@ void wxWidgetCocoaImpl::GetPosition( int &x, int &y ) const
     wxRect r = wxFromNSRect( [m_osxView superview], [m_osxView frame] );
     x = r.GetLeft();
     y = r.GetTop();
-    
+
     // under Cocoa we might have a contentView in the wxParent to which we have to
     // adjust the coordinates
     wxWindowMac* parent = GetWXPeer()->GetParent();
@@ -3142,7 +3156,7 @@ void wxWidgetCocoaImpl::GetLayoutInset(int &left , int &top , int &right, int &b
 
 namespace
 {
-    
+
 void SetSubviewsNeedDisplay( NSView *view )
 {
     for ( NSView *sub in view.subviews )
@@ -3335,7 +3349,7 @@ void wxWidgetCocoaImpl::Embed( wxWidgetImpl *parent )
 
     wxASSERT_MSG( container != NULL , wxT("No valid mac container control") ) ;
     [container addSubview:m_osxView];
-    
+
     // User panes will be frozen elsewhere
     if( m_wxPeer->IsFrozen() && !IsUserPane() )
         SetDrawingEnabled(false);
@@ -3364,14 +3378,14 @@ void wxWidgetCocoaImpl::SetBackgroundColour( const wxColour &col )
 bool wxWidgetCocoaImpl::SetBackgroundStyle( wxBackgroundStyle style )
 {
     BOOL opaque = ( style == wxBG_STYLE_PAINT );
-    
+
     if ( [m_osxView respondsToSelector:@selector(setOpaque:) ] )
     {
         [m_osxView setOpaque: opaque];
         if ( style == wxBG_STYLE_TRANSPARENT )
             [m_osxView setBackgroundColor:[NSColor clearColor]];
     }
-    
+
     return true ;
 }
 
@@ -3427,7 +3441,7 @@ void wxWidgetCocoaImpl::SetLabel( const wxString& title, wxFontEncoding encoding
             [attrString endEditing];
 
             [(id)m_osxView setAttributedTitle:attrString];
-            
+
             [attrString release];
 
             return;
@@ -3676,7 +3690,7 @@ void wxWidgetCocoaImpl::SetControlSize( wxWindowVariant variant )
     if ( [m_osxView isKindOfClass:[NSScrollView class] ] )
     {
         NSView* targetView = [(NSScrollView*) m_osxView documentView];
-    
+
         if ( [targetView respondsToSelector:@selector(setControlSize:)] )
             [targetView setControlSize:size];
         else if ([targetView respondsToSelector:@selector(cell)])
@@ -3725,7 +3739,7 @@ void wxWidgetCocoaImpl::SetToolTip(wxToolTip* tooltip)
         wxCFStringRef cf( tooltip->GetTip() , m_wxPeer->GetFont().GetEncoding() );
         [m_osxView setToolTip: cf.AsNSString()];
     }
-    else 
+    else
     {
         [m_osxView setToolTip:nil];
     }
@@ -3744,7 +3758,7 @@ void wxWidgetCocoaImpl::InstallEventHandler( WXWidget control )
         }
         else
             [c setAction: @selector(controlAction:)];
-        
+
         if ([c respondsToSelector:@selector(setDoubleAction:)])
         {
             [c setDoubleAction: @selector(controlDoubleAction:)];
@@ -3759,19 +3773,22 @@ void wxWidgetCocoaImpl::InstallEventHandler( WXWidget control )
 
 bool wxWidgetCocoaImpl::EnableTouchEvents(int eventsMask)
 {
-    if ( HasUserMouseHandling() )
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
+    if ( WX_IS_MACOS_AVAILABLE(10, 10) )
     {
-        if ( eventsMask == wxTOUCH_NONE )
+        if ( HasUserMouseHandling() )
         {
-            if ( wxCocoaGestures::EraseForObject(this) )
+            if ( eventsMask == wxTOUCH_NONE )
             {
-                [m_osxView setAcceptsTouchEvents:NO];
+                if ( wxCocoaGestures::EraseForObject(this) )
+                {
+                    [m_osxView setAcceptsTouchEvents:NO];
+                }
+                //else: we didn't have any gesture data anyhow
             }
-            //else: we didn't have any gesture data anyhow
-        }
-        else // We do want to have gesture events.
-        {
-            // clang does not see that the owning object always destroys its extra field
+            else // We do want to have gesture events.
+            {
+                // clang does not see that the owning object always destroys its extra field
 #ifndef __clang_analyzer__
             wxCocoaGestures::StoreForObject
             (
@@ -3779,12 +3796,14 @@ bool wxWidgetCocoaImpl::EnableTouchEvents(int eventsMask)
                 new wxCocoaGesturesImpl(this, m_osxView, eventsMask)
             );
 #endif
-            
-            [m_osxView setAcceptsTouchEvents:YES];
-        }
 
-        return true;
+                [m_osxView setAcceptsTouchEvents:YES];
+            }
+
+            return true;
+        }
     }
+#endif // MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_10
 
     wxUnusedVar(eventsMask);
     return false;
@@ -3803,12 +3822,12 @@ bool wxWidgetCocoaImpl::DoHandleCharEvent(NSEvent *event, NSString *text)
               ++it )
         {
             wxKeyEvent wxevent(wxEVT_CHAR);
-            
+
             // if we have exactly one character resulting from the event, then
             // set the corresponding modifiers and raw data from the nsevent
             // otherwise leave these at defaults, as they probably would be incorrect
             // anyway (IME input)
-            
+
             if ( event != nil && length == 1)
             {
                 SetupKeyEvent(wxevent,event,text);
@@ -3824,14 +3843,14 @@ bool wxWidgetCocoaImpl::DoHandleCharEvent(NSEvent *event, NSString *text)
                 wxevent.m_uniChar = aunichar;
 #endif
                 wxevent.m_keyCode = aunichar < 0x80 ? aunichar : WXK_NONE;
-                
+
                 wxevent.SetEventObject(peer);
                 wxevent.SetId(peer->GetId());
 
                 if ( event )
                     wxevent.SetTimestamp( (int)([event timestamp] * 1000) ) ;
             }
-            
+
             result = peer->OSXHandleKeyEvent(wxevent) || result;
         }
     }
@@ -3949,7 +3968,7 @@ void wxWidgetCocoaImpl::DoNotifyFocusSet()
     NSResponder* responder = wxNonOwnedWindowCocoaImpl::GetFormerFirstResponder();
     NSView* otherView = wxOSXGetViewFromResponder(responder);
     wxWidgetImpl* otherWindow = FindFromWXWidget(otherView);
-    
+
     // It doesn't make sense to notify about the focus set if it's the same
     // control in the end, and just a different subview
     if ( otherWindow != this )
@@ -3961,7 +3980,7 @@ void wxWidgetCocoaImpl::DoNotifyFocusLost()
     NSResponder * responder = wxNonOwnedWindowCocoaImpl::GetNextFirstResponder();
     NSView* otherView = wxOSXGetViewFromResponder(responder);
     wxWidgetImpl* otherWindow = FindBestFromWXWidget(otherView);
-    
+
     // It doesn't make sense to notify about the loss of focus if it's the same
     // control in the end, and just a different subview
     if ( otherWindow != this )
@@ -4013,8 +4032,8 @@ void wxWidgetCocoaImpl::SetCursor(const wxCursor& cursor)
         NSRect location = NSZeroRect;
         location.origin = [NSEvent mouseLocation];
         location = [[m_osxView window] convertRectFromScreen:location];
-        NSPoint locationInView = [m_osxView convertPoint:location.origin fromView:nil];        
-        
+        NSPoint locationInView = [m_osxView convertPoint:location.origin fromView:nil];
+
         if( NSMouseInRect(locationInView, [m_osxView bounds], YES) )
         {
             [(NSCursor*)cursor.GetHCURSOR() set];
@@ -4123,7 +4142,7 @@ wxWidgetImpl* wxWidgetImpl::CreateUserPane( wxWindowMac* wxpeer, wxWindowMac* WX
 wxWidgetImpl* wxWidgetImpl::CreateContentView( wxNonOwnedWindow* now )
 {
     NSWindow* tlw = now->GetWXWindow();
-    
+
     wxWidgetCocoaImpl* c = NULL;
     if ( now->IsNativeWindowWrapper() )
     {
-- 
2.45.2

